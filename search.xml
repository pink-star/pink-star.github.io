<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog搭建记录</title>
    <url>/2020/06/06/Blog%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="使用Hexo-github-gitee、coding-搭建博客"><a href="#使用Hexo-github-gitee、coding-搭建博客" class="headerlink" title="使用Hexo + github(gitee、coding)搭建博客"></a>使用Hexo + github(gitee、coding)搭建博客</h1><h2 id="下载并安装nodejs"><a href="#下载并安装nodejs" class="headerlink" title="下载并安装nodejs"></a>下载并安装nodejs</h2><p>&nbsp; &nbsp;首先到nodejs的<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载对应自己<br>&nbsp; &nbsp;操作系统的LTS(长期支持版)的版本<br>&nbsp; &nbsp;&nbsp; &nbsp;这里以win10为例：    </p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/nodejs_dl.jpg" alt="nodejs"><br>&nbsp; &nbsp;&nbsp; &nbsp;下载完后一直下一步即可  </p>
<h2 id="安装Hexo博客框架"><a href="#安装Hexo博客框架" class="headerlink" title="安装Hexo博客框架"></a>安装Hexo博客框架</h2><p>&nbsp; &nbsp;打开终端，windows就是用cmd(推荐使用git，因为部分命令会不一样)</p>
<ul>
<li><p>安装cnpm<br>&nbsp; &nbsp; 由于国内镜像源速度较慢，所以使用cnpm会好一点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;使用cnpm -v可以查看版本</p>
</li>
<li><p>安装Hexo框架  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;安装完后可使用hexo -v验证时候安装成功</p>
</li>
</ul>
<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><ul>
<li>创建存放Blog的目录<br>Linux和mac终端，git<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br></pre></td></tr></table></figure></li>
<li>进入blog目录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure></li>
<li>使用hexo生成博客<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&nbsp; &nbsp;到这里搭建其实就完成了，我们可以使用&nbsp;hexo s来启动博客<br><img src="https://raw.githubusercontent.com/pink-star/image/master/hexos.png" alt=""><br>&nbsp; &nbsp;这时候就会再本地的4000端口启动，再浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;即可看到你的博客<br><img src="https://raw.githubusercontent.com/pink-star/image/master/1591430885(1).png" alt=""></p>
<h2 id="将博客部署到github-gitee、coding"><a href="#将博客部署到github-gitee、coding" class="headerlink" title="将博客部署到github(gitee、coding)"></a>将博客部署到github(gitee、coding)</h2><ul>
<li><p>在github创建一个存放博客的仓库<br>登入你的github然后再左上角选择新建仓库<br><img src="https://raw.githubusercontent.com/pink-star/image/master/github_new.png" alt=""><br>填好信息<br><img src="https://raw.githubusercontent.com/pink-star/image/master/biuld_ck.jpg" alt=""></p>
</li>
<li><p>安装git的部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置配置文件_config.yml<br>打开你的Blog目录下的_config.yml文件，到最后一行<br><img src="https://raw.githubusercontent.com/pink-star/image/master/cof.png" alt=""></p>
</li>
</ul>
<p>将其改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: 你的GitHub仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>&nbsp; &nbsp;若有多个不同平台的仓库，如下增加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    coding: xxxxx</span><br><span class="line">    gitee: xxxxx</span><br><span class="line">    github: xxxxx</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ul>
<li>开始部署到远端<br>在终端中，blog目录下执行命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
&nbsp; &nbsp;第一次部署会要你输入你的github账号和密码，输入即可</li>
</ul>
<p>这是，一个属于你的个人博客就搭建好了</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C#基础</title>
    <url>/2020/10/11/C-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="C-程序包括部分"><a href="#C-程序包括部分" class="headerlink" title="C# 程序包括部分"></a>C# 程序包括部分</h1><ul>
<li>命名空间声明（Namespace declaration）  </li>
<li>一个 class  </li>
<li>Class 方法  </li>
<li>Class 属性  </li>
<li>一个 Main 方法  </li>
<li>语句（Statements）&amp; 表达式（Expressions）  </li>
<li>注释</li>
</ul>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;    &#x2F;&#x2F;使用System命名空间</span><br><span class="line">namespace HelloWorldApplication   &#x2F;&#x2F;命名空间的声明</span><br><span class="line">&#123;</span><br><span class="line">   class HelloWorld     &#x2F;&#x2F;类声明</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)  &#x2F;&#x2F;Main方法</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using 用于在程序中包含命名空间，一个程序可包含多个using语句</p>
<h1 id="C-中的变量类型"><a href="#C-中的变量类型" class="headerlink" title="C#中的变量类型"></a>C#中的变量类型</h1><p>C#是一门强类型编程语言（数据如果受到数据类型的约束，就叫做强类型语言），在 C# 中，变量分为以下几种类型：<br>C#的五大数据类型<br>类（Class）                                         如：Windows、Form、Console、String<br>结构体（Structure）                            如：int32、int64、Single、Double<br>枚举（Enumeration）                          如：HorizontalAlignment、Visibility<br>接口<br>委托  </p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/datatype.png" alt="">  </p>
<p><strong>变量 = 以变量名为所对应的内存地址为起点、数据类型要求的储存空间为长度的一块内存区域</strong></p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/bianliang.png" alt=""> </p>
<h2 id="引用类型，类似C-的引用"><a href="#引用类型，类似C-的引用" class="headerlink" title="引用类型，类似C++的引用"></a>引用类型，类似C++的引用</h2><h3 id="对象-Object-类型："><a href="#对象-Object-类型：" class="headerlink" title="对象( Object )类型："></a>对象( Object )类型：</h3><p>当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Obj &#x3D; 100     &#x2F;&#x2F; 装箱</span><br><span class="line">Int num &#x3D; ( int ) obj;    &#x2F;&#x2F; 拆箱</span><br></pre></td></tr></table></figure>
<p>利用装箱和拆箱功能，可通过允许值类型的任何值与Object 类型的值相互转换，将值类型与引用类型链接起来</p>
<h3 id="动态-Dynamic-类型："><a href="#动态-Dynamic-类型：" class="headerlink" title="动态( Dynamic )类型："></a>动态( Dynamic )类型：</h3><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的</p>
<h3 id="字符串（String）类型："><a href="#字符串（String）类型：" class="headerlink" title="字符串（String）类型："></a>字符串（String）类型：</h3><p>类似与C++的字符串，不同的是  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str &#x3D; @&quot;C:\t \n C&quot;        &#x2F;&#x2F;输出： C:\t \n C</span><br></pre></td></tr></table></figure>
<p>即字符串前加@可以将转义字符 ( \ )当作普通字符对待  </p>
<h3 id="值类型与引用类型在内存中的存储"><a href="#值类型与引用类型在内存中的存储" class="headerlink" title="值类型与引用类型在内存中的存储"></a>值类型与引用类型在内存中的存储</h3><ul>
<li><p>值类型在声明时，系统就会根据数据类型的大小，分配对应的内存，如ushort就会分配16个比特(2个字节)的内存</p>
</li>
<li><p>引用类型在声明时计算机只会分配4个字节(32个比特)的内存（栈内存），并全部初始化为0。只有当实例化（new）的时候才会分配对应大小（堆内存），然后将该内存最低位的地址赋值给引用声明的变量</p>
</li>
</ul>
<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型。利用装箱和拆箱功能，可通过允许值类型的任何值与Object 类型的值相互转换，将值类型与引用类型链接起来</p>
<ul>
<li>装箱：把栈上的值类型的值，封装成一个object的类型的变量、放到堆上（即原本的值在栈上，使用Object装箱时，在堆上找一块可用内存，然后将原本的值赋上，在将堆的地址赋值给栈上的object实例）</li>
<li>拆箱：将堆上Object类型的实例的值拆成目标数据类型存储到栈中，<strong>被装过箱的对象才能被拆箱</strong></li>
<li>Ps: 装箱和拆箱会损失程序的性能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int val &#x3D; 100; </span><br><span class="line">object obj &#x3D; val;</span><br></pre></td></tr></table></figure>

<p>这是一个装箱过程，将值类型转换为引用类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int val &#x3D; 100; </span><br><span class="line">object obj &#x3D; val; </span><br><span class="line">int num &#x3D; (int) obj;</span><br></pre></td></tr></table></figure>

<p>这是一个拆箱的过程，首先先将值类型转换成了引用类型，再将引用类型转换成了值类型</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换可以分为三种</p>
<ul>
<li>隐式类型转换</li>
<li>显式类型转换</li>
<li>自定义类型转换</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/tpyechange.png" alt=""> </p>
<h3 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h3><p>当自己书写的类需要进行类型转换时，就需要书写一个自定义额类型转换函数，该类型转换函数应书写在需要被转换的类中。如有一个石头类，一个猴子类，如果要将石头类装换成猴子类，就需要将类型转换函数卸载石头类中，且函数名需要为猴子类的类名。该成员函数的修饰符需要有explicit（显式类型转换），operator，static。在调用是需要使用和强制类型转换一样的方式 ： Money Sun  =  (Money)ColorStone;</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Stone ColorST &#x3D; new Stone();</span><br><span class="line">            ColorST.age &#x3D; 5000;</span><br><span class="line">            Monkey Sun &#x3D; (Monkey)ColorST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">class Stone</span><br><span class="line">&#123;</span><br><span class="line">	public int age;</span><br><span class="line">	public static explicit operator Monkey(Stone stone)</span><br><span class="line">	&#123;</span><br><span class="line">		Monkey mk &#x3D; new Monkey();</span><br><span class="line">		mk.age &#x3D; stone.age &#x2F; 100;</span><br><span class="line">		return mk;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monkey</span><br><span class="line">&#123;</span><br><span class="line">	public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是想使用隐式类型转换，只需要将explicit换为implicit即可，其他不变，使用时不需要括号</p>
<h1 id="C-支持的其他一些重要的运算符"><a href="#C-支持的其他一些重要的运算符" class="headerlink" title="C# 支持的其他一些重要的运算符"></a>C# 支持的其他一些重要的运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">作用</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sizeof</td>
<td align="center">返回数据类型的大小</td>
<td align="center">sizeof(int)，将返回 4.</td>
</tr>
<tr>
<td align="center">typeof()</td>
<td align="center">返回 class 的类型</td>
<td align="center">typeof(StreamReader);</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">返回变量的地址</td>
<td align="center">&amp;a; 将得到变量的实际地址</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">变量的指针</td>
<td align="center">*a; 将指向一个变量</td>
</tr>
<tr>
<td align="center">? :</td>
<td align="center">条件表达式</td>
<td align="center">如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr>
<td align="center">is</td>
<td align="center">判断对象是否未某一类型</td>
<td align="center">Object obj = new<br>StringReader(“Hello”);<br>StringReader r = obj as StringReader;</td>
</tr>
</tbody></table>
<h1 id="C-循环与判断语句"><a href="#C-循环与判断语句" class="headerlink" title="C#循环与判断语句"></a>C#循环与判断语句</h1><p>与C++基本一致，但不同的是<br>foreach 循环<br>C# 中 for 循环的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach (int element in fibarray)</span><br><span class="line">&#123;</span><br><span class="line">    System.Console.WriteLine(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-访问修饰符"><a href="#C-访问修饰符" class="headerlink" title="C#访问修饰符"></a>C#访问修饰符</h1><ul>
<li>public：所有对象都可以访问；</li>
<li>private：对象本身在对象内部可以访问；</li>
<li>protected：只有该类对象及其子类对象可以访问</li>
<li>internal：同一个程序集的对象可以访问；  ( 同一个命名空间下可访问 )</li>
<li>protected internal：访问限于当前程序集或派生自包含类的类型   (同一个命名空间内的派生类可访问)</li>
</ul>
<h1 id="C-的参数与参数传递"><a href="#C-的参数与参数传递" class="headerlink" title="C#的参数与参数传递"></a>C#的参数与参数传递</h1><p>C#中的参数细致的可以分为7种，分别是：</p>
<ul>
<li>传值参数</li>
<li>输出参数</li>
<li>引用参数</li>
<li>数组参数</li>
<li>具名参数</li>
<li>可选参数</li>
<li>拓展方法（this参数）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/pram.png" alt=""> </p>
<ul>
<li><p>值传递<br>  与C++一致</p>
</li>
<li><p>引用传递<br>在函数声明是参数列表中需要使用  ref  关键字声明引用参数<br>调用时也需要加上 ref 关键字  </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Public void fun( ref int x , ref int y )</span><br><span class="line">&#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br><span class="line">Classname.fun(ref a , ref b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出参数<br>类似于return，return只从函数中返回一个值，可用输出参数从函数中返回多个值，用 out 声明  </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Public void getValue( out int x )</span><br><span class="line">&#123;</span><br><span class="line">	Int temp &#x3D; 5;</span><br><span class="line">	x &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;--------------------------&#x2F;</span><br><span class="line">Int a &#x3D;  100;</span><br><span class="line">Classname.getValue( out a);   &#x2F;&#x2F; 调用该函数后a变为了5</span><br></pre></td></tr></table></figure>
<p>  和引用传递差不多，但引用传递的参数一定要初始化</p>
</li>
<li><p>具名参数：</p>
<ul>
<li>可以使得参数不需要按照顺序来传递</li>
<li>具名参数优点，提高代码可读性，参数位置不受参数列表限制</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Dis(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(&quot;&#123;0&#125;,You are &#123;1&#125; yearsold&quot;,name,age);</span><br><span class="line">&#125;</span><br><span class="line">Dis(name: &quot;JoJo&quot;, age:21);</span><br></pre></td></tr></table></figure>

<ul>
<li>拓展方法(参数需要this)<ul>
<li>拓展方法的目的是为目标数据类型 “ 追加 “ 方法</li>
<li>方法必须是public、static</li>
<li>方法的形参列表的第一个参数必须由this修饰</li>
<li>拓展方法必须由一个静态类（一般命名为TypeExtension）收纳（即为一个静态类的静态成员）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class DoubleExtension</span><br><span class="line">&#123;</span><br><span class="line">	public static double Round(this double input, int num)</span><br><span class="line">	&#123;</span><br><span class="line">		return Math.Round(input, num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时double类型就被拓展了一个Round方法了</p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/tuozhanarg.png" alt=""> </p>
<h1 id="C-可空类型-Nullable"><a href="#C-可空类型-Nullable" class="headerlink" title="C#可空类型( Nullable )"></a>C#可空类型( Nullable )</h1><p>可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值<br>声明一个可空类型数据的语法：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int? x &#x3D; null;</span><br><span class="line">Int? x &#x3D; new int?();</span><br><span class="line">Nullable&lt;int&gt; x &#x3D; new Nullable&lt;int&gt;();</span><br></pre></td></tr></table></figure>
<p>Null合并运算符( ?? )<br>为类型转换定义了一个预设值，以防可空类型的值为Null，把操作数类型隐式转换为另一个可空（或不可空）的值类型操作数的类型<br>即，第一个数为null，则运算符返回第二个操作数的值，否则返回第一个操作数的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double? num1 &#x3D; null;</span><br><span class="line">double? num2 &#x3D; 3.1415;</span><br><span class="line">double num3;</span><br><span class="line">num3 &#x3D; num1 ?? 5.34;      &#x2F;&#x2F; num1 如果为空值则返回 5.34</span><br><span class="line">Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);        </span><br><span class="line">num3 &#x3D; num2 ?? 5.34;     &#x2F;&#x2F;此时num3为3.1415</span><br><span class="line">Console.WriteLine(&quot;num3 的值： &#123;0&#125;&quot;, num3);</span><br></pre></td></tr></table></figure>

<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C#数组"></a>C#数组</h1><h2 id="C-多维数组"><a href="#C-多维数组" class="headerlink" title="C#多维数组"></a>C#多维数组</h2><ul>
<li>如二维数组：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[ , ] nums ;      （类似于一个坐标的形式）</span><br><span class="line">&#x2F;&#x2F;问数组元素时nums[ 2 , 3 ]表示访问第三行第四列</span><br></pre></td></tr></table></figure></li>
<li>三维数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [ ,  , ] nums ;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="C-交错数组-即数组的数组"><a href="#C-交错数组-即数组的数组" class="headerlink" title="C#交错数组 ( 即数组的数组 )"></a>C#交错数组 ( 即数组的数组 )</h2><p>交错数组是一个一维数组，但数组的元素都是长度不同或者相同的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [ ][ ] scores ;        &#x2F;&#x2F;声明一个数组，并不在内存中创建</span><br><span class="line">			</span><br><span class="line">&#x2F;&#x2F;创建一个数组</span><br><span class="line">int [ ][ ] scores &#x3D; new int[5][ ];</span><br><span class="line">for (int i &#x3D; 0; I &lt; scores.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">	scores[i] &#x3D; new int[4] ;</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line">&#x2F;&#x2F;初始化一个交错数组</span><br><span class="line">int [ ][ ] scores &#x3D; new int[2][ ] &#123; new int[ ] &#123;92,93,54&#125; , new int[ ] &#123; 46 , 56 , 56 , 43&#125;&#125; ;</span><br></pre></td></tr></table></figure>

<h2 id="C-参数数组"><a href="#C-参数数组" class="headerlink" title="C#参数数组"></a>C#参数数组</h2><p>在不知道函数需要的参数数目时，可以使用参数数组<br>Params 关键字 ：<br>使得调用数组为形参的方法时，可以传数组实参，也可以传一组数组元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Public int Addnums( params int[ ] arr )</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line">Classname.Addnums(50, 20 , 56 , 35 , 57) ; </span><br><span class="line">Classname.Addnums(arrey);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#委托与事件</title>
    <url>/2020/10/11/C-%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="C-委托"><a href="#C-委托" class="headerlink" title="C#委托"></a>C#委托</h1><p><strong>C#中的委托，其实就是C++中函数指针的升级版</strong></p>
<p><strong>前言：</strong></p>
<p>程序中一切皆地址</p>
<ul>
<li>变量（数据）是以某个地址为起点的一段内存中所存储的值</li>
<li>函数（算法）是以某个地址为起点的一段内存中所 存储的一组机器语言</li>
</ul>
<a id="more"></a>

<p>直接调用与间接调用</p>
<ul>
<li>直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在的地址并开始执行 -&gt; 返回</li>
<li>间接调用：通过函数指针来调用函数，CPU通过读取函数指针储存的值获得函数所在的地址并开始执行 -&gt; 返回</li>
</ul>
<h2 id="自带委托类型"><a href="#自带委托类型" class="headerlink" title="自带委托类型"></a>自带委托类型</h2><ul>
<li>Action&lt;&gt;委托<ul>
<li>Action委托的是不带返回值的函数，但可以有参数的函数</li>
</ul>
</li>
<li>Func&lt;&gt;委托<ul>
<li>Func委托的是带返回值，可以有参数的函数</li>
</ul>
</li>
</ul>
<p>Action与Func使用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	static void Main(string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Calculater calculater &#x3D; new Calculater();</span><br><span class="line">		Action action &#x3D; new Action(calculater.Report);</span><br><span class="line"></span><br><span class="line">		action.Invoke();	&#x2F;&#x2F;使用Invoke调用</span><br><span class="line">		action();			&#x2F;&#x2F;直接调用</span><br><span class="line"></span><br><span class="line">		Func&lt;int, int, int&gt; func1 &#x3D; new Func&lt;int, int, int&gt;(calculater.Add);</span><br><span class="line">		Func&lt;int, int, int&gt; func2 &#x3D; new Func&lt;int, int, int&gt;(calculater.Sub);</span><br><span class="line"></span><br><span class="line">		int Add_Result &#x3D; func1.Invoke(100, 100);</span><br><span class="line">		int Sub_Result &#x3D; func2.Invoke(100, 100);</span><br><span class="line"></span><br><span class="line">		Console.WriteLine(Add_Result);</span><br><span class="line">		Console.WriteLine(Sub_Result);</span><br><span class="line"></span><br><span class="line">		Console.ReadKey();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义了一个计算类，拥有一个无返回值函数Report以及两个返回值为int的函数</span><br><span class="line">class Calculater</span><br><span class="line">&#123;</span><br><span class="line">	public void Report()</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(&quot;Calculater has three function&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int Add(int a , int b)</span><br><span class="line">	&#123;</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int Sub(int a , int b)</span><br><span class="line">	&#123;</span><br><span class="line">		return a - b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义委托delegate"><a href="#自定义委托delegate" class="headerlink" title="自定义委托delegate"></a>自定义委托delegate</h2><h3 id="委托的声明"><a href="#委托的声明" class="headerlink" title="委托的声明"></a>委托的声明</h3><ul>
<li><p>委托是一种类，类是数据类型所以委托也是一种数据类型</p>
</li>
<li><p>委托与所封装的方法必须“类型兼容”（即返回值类型、参数列表类型得保持一致）</p>
<p>声明方法：作用域 delegate 返回值类型  委托名（参数列表）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate double Calc(double num1 , double num2);</span><br></pre></td></tr></table></figure>

<h3 id="委托的一般使用场景"><a href="#委托的一般使用场景" class="headerlink" title="委托的一般使用场景"></a>委托的一般使用场景</h3><p>在日常使用中，委托的使用场景一般都是将委托作为参数，传进函数里去使用，这种把委托当作参数传进函数的使用方法，又具体分为两种</p>
<ul>
<li>模板方法<ul>
<li>通过传进来的委托参数，借用指定的外部方法来产生结果</li>
<li>一般有返回值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace Factory</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Box_Factory bf &#x3D; new Box_Factory();					&#x2F;&#x2F;包装工厂的实例</span><br><span class="line">            </span><br><span class="line">            ProductFactory pf &#x3D; new ProductFactory();				&#x2F;&#x2F;工厂类的实例，用于调用MakePizz()方法和MakeToyCar()方法</span><br><span class="line">            Func&lt;Product&gt; func1 &#x3D; new Func&lt;Product&gt;(pf.MakePizz);		&#x2F;&#x2F;MakePizz()方法的委托实例</span><br><span class="line">            Func&lt;Product&gt; func2 &#x3D; new Func&lt;Product&gt;(pf.MakeToyCar);		&#x2F;&#x2F;MakeToyCar()方法的委托实例</span><br><span class="line"></span><br><span class="line">            Box box1 &#x3D; bf.MakeBox(func1);				&#x2F;&#x2F;将委托实例传进模板方法调用</span><br><span class="line">            Box box2 &#x3D; bf.MakeBox(func2);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(box1.product.Name);</span><br><span class="line">            Console.WriteLine(box2.product.Name);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Product</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Box</span><br><span class="line">    &#123;</span><br><span class="line">        public Product product &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Box_Factory</span><br><span class="line">    &#123;</span><br><span class="line">        public Box MakeBox(Func&lt;Product&gt; product)	&#x2F;&#x2F;这就是一个模板方法，接收一个委托类型的参数</span><br><span class="line">        &#123;</span><br><span class="line">            Box box &#x3D; new Box();</span><br><span class="line">            box.product &#x3D; product.Invoke();</span><br><span class="line">            return box;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ProductFactory</span><br><span class="line">    &#123;</span><br><span class="line">        public Product MakePizz()</span><br><span class="line">        &#123;</span><br><span class="line">            Product product &#x3D; new Product();</span><br><span class="line">            product.Name &#x3D; &quot;pizza&quot;;</span><br><span class="line">            return product;</span><br><span class="line">        &#125;</span><br><span class="line">        public Product MakeToyCar()</span><br><span class="line">        &#123;</span><br><span class="line">            Product product &#x3D; new Product();</span><br><span class="line">            product.Name &#x3D; &quot;ToyCar&quot;;</span><br><span class="line">            return product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述例子，可见，使用模板方法之后，Product类、Box类、Box_Factory类都不需要修改，只需要去拓展ProductFactory类，就可以生产各种产品，只需要将生产产品的方法封装在委托类型的对象里传给MakeBox模板方法，模板方法就一定能包装好这个产品。通过模板方法，就最大限度的实现了代码复用</p>
<ul>
<li><p>回调（callback）方法    </p>
<ul>
<li><p>什么是回调？</p>
<p>回调方法指的就是，某个方法，我选择是否调用，而且回调方法还可以让我们动态的选择调用什么方法</p>
<p>举个例子，假设A给了B一张名片，让B有需要帮忙的时候就打掉话给A，某天需要帮忙的时候，B就会打电话📞给A，调用A的某些功能来解决某些问题，如果不需要帮忙，就一直不会调用A的功能，这时候A和B之间就构成了一种回调关系</p>
</li>
<li><p>一般没有返回值</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Box_Factory bf &#x3D; new Box_Factory();</span><br><span class="line">        ProductFactory pf &#x3D; new ProductFactory();</span><br><span class="line">        Func&lt;Product&gt; func1 &#x3D; new Func&lt;Product&gt;(pf.MakePizz);</span><br><span class="line">        Func&lt;Product&gt; func2 &#x3D; new Func&lt;Product&gt;(pf.MakeToyCar);</span><br><span class="line"></span><br><span class="line">        logger loge &#x3D; new logger();			&#x2F;&#x2F;实例化日志类</span><br><span class="line">        Action&lt;Product&gt; action1 &#x3D; new Action&lt;Product&gt;(loge.log);	&#x2F;&#x2F;实例化log方法的委托</span><br><span class="line"></span><br><span class="line">        Box box1 &#x3D; bf.MakeBox(func1, action1);				&#x2F;&#x2F;传入log委托</span><br><span class="line">        Box box2 &#x3D; bf.MakeBox(func2, action1);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(box1.product.Name);</span><br><span class="line">        Console.WriteLine(box2.product.Name);</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class logger        &#x2F;&#x2F;被回调的方法，用于记录程序运行状态</span><br><span class="line">&#123;</span><br><span class="line">    public void log(Product product)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; is make in &#123;1&#125; ,it cost &#123;2&#125;&quot;, product.Name, DateTime.UtcNow, product.price);&#x2F;&#x2F;记录什么产品被创建以及创建时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int price &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">    public Product product &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box_Factory</span><br><span class="line">&#123;</span><br><span class="line">    public Box MakeBox(Func&lt;Product&gt; product, Action&lt;Product&gt; log)	&#x2F;&#x2F;接受log回调方法</span><br><span class="line">    &#123;</span><br><span class="line">        Box box &#x3D; new Box();</span><br><span class="line">        box.product &#x3D; product.Invoke();</span><br><span class="line">        if (box.product.price &gt; 50)      &#x2F;&#x2F;判断是否调用回调方法</span><br><span class="line">        &#123;</span><br><span class="line">            log(box.product);           &#x2F;&#x2F;调用回调方法</span><br><span class="line">        &#125;</span><br><span class="line">        return box;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProductFactory</span><br><span class="line">&#123;</span><br><span class="line">    public Product MakePizz()</span><br><span class="line">    &#123;</span><br><span class="line">        Product product &#x3D; new Product();</span><br><span class="line">        product.Name &#x3D; &quot;pizza&quot;;</span><br><span class="line">        product.price &#x3D; 15;</span><br><span class="line">        return product;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public Product MakeToyCar()</span><br><span class="line">    &#123;</span><br><span class="line">        Product product &#x3D; new Product();</span><br><span class="line">        product.Name &#x3D; &quot;ToyCar&quot;;</span><br><span class="line">        product.price &#x3D; 100;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是回调方法还是模板方法，本质都是一个外部方法封装成一个委托，将外部方法传入主调方法内部，再进行间接调用</p>
<h2 id="委托的高级使用"><a href="#委托的高级使用" class="headerlink" title="委托的高级使用"></a>委托的高级使用</h2><ul>
<li><p>多播委托：</p>
</li>
<li><ul>
<li><p>即一个委托内部封装了多个方法</p>
</li>
<li><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托</p>
</li>
<li><p>执行顺序为合并的先后顺序</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Student std1 &#x3D; new Student() &#123; iD &#x3D; 1, Pencolor &#x3D; ConsoleColor.Red &#125;;</span><br><span class="line">        Student std2 &#x3D; new Student() &#123; iD &#x3D; 2, Pencolor &#x3D; ConsoleColor.Blue &#125;;</span><br><span class="line">        Student std3 &#x3D; new Student() &#123; iD &#x3D; 3, Pencolor &#x3D; ConsoleColor.Green &#125;;</span><br><span class="line"></span><br><span class="line">        Action action1 &#x3D; new Action(std1.DoHomeWork);</span><br><span class="line">        Action action2 &#x3D; new Action(std2.DoHomeWork);</span><br><span class="line">        Action action3 &#x3D; new Action(std3.DoHomeWork);</span><br><span class="line">		</span><br><span class="line">        &#x2F;&#x2F;将action2和action3都合并到action1</span><br><span class="line">        action1 +&#x3D; action2;</span><br><span class="line">        action1 +&#x3D; action3;</span><br><span class="line"></span><br><span class="line">        action1();	</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public int iD &#123; get; set; &#125;</span><br><span class="line">    public ConsoleColor Pencolor &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public void DoHomeWork()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.ForegroundColor &#x3D; this.Pencolor;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125; had do HomeWork &#123;1&#125; hour&quot;, iD, i);</span><br><span class="line">            Thread.Sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序运行之后，回先执行std1的方法，再执行std2的方法，再执行std3的方法</p>
<ul>
<li>隐式异步调用<ul>
<li>同步与异步<ul>
<li>同步：你做完了我做（在你的基础上）接着做</li>
<li>异步：两个人同时做（相当于平时说的同步进行）</li>
</ul>
</li>
<li>同步调用与异步调用<ul>
<li>每一个运行的程序就是一个进程</li>
<li>每个进程可以有多个线程</li>
<li>同步调用是在一个线程内</li>
<li>异步调用的底层机理是多线程</li>
<li>串行 = 同步 = 单线程 || 并行 = 异步 = 多线程</li>
</ul>
</li>
<li>隐式多线程与显式多线程<ul>
<li>直接同步调用：使用方法名</li>
<li>间接同步调用：使用单播、多播委托的Invoke方法</li>
<li>隐式异步调用：使用委托的BeginInvoke方法<ul>
<li>调用BeginInvoke会创建一个线程来执行该方法，BeginInvoke需要两个参数，一个是下一步该做什么的回调函数，如果不需要可以填null，第二个是参数列表，没有填null</li>
</ul>
</li>
<li>显式异步调用：使用Thread或者Task </li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="C-事件"><a href="#C-事件" class="headerlink" title="C#事件"></a>C#事件</h1><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断</p>
<p>概念上来说，事件是一种使对象或类能够提供通知的成员</p>
<p>事件模型的五个组成部分：</p>
<ul>
<li>事件的拥有者      —–对象</li>
<li>事件成员（事件本身）   —–成员</li>
<li>事件的响应者    —–对象</li>
<li>事件处理器   —–成员 本质上是一个回调方法</li>
<li>事件订阅   —–把事件处理器与事件关联在一起，本质上是一种以委托类型为基础的约定</li>
</ul>
<p>事件处理器订阅事件，并不是事件响应者订阅事件，五个组成部分的包含关系可以如下图</p>
<ol>
<li><p>拥有者与响应者互不包含</p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/event1.png" alt=""> </p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"> using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace Event_1_notinclude</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Form form &#x3D; new Form();     &#x2F;&#x2F;事件拥有者</span><br><span class="line">            Contrler contrler &#x3D; new Contrler(form);     &#x2F;&#x2F;事件响应者</span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Contrler</span><br><span class="line">    &#123;</span><br><span class="line">        Form form;</span><br><span class="line">        public Contrler(Form form)</span><br><span class="line">        &#123;</span><br><span class="line">             if(form !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                this.form &#x3D; form;</span><br><span class="line">                &#x2F;&#x2F;Click事件</span><br><span class="line">                this.form.Click +&#x3D; this.FormClick;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;事件处理器</span><br><span class="line">        private void FormClick(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            this.form.Text &#x3D; DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>响应者包含着事件的拥有者，如windows的窗体和按钮，窗体时响应者，按钮时拥有者，窗体包含着按钮</p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/event2.png" alt=""> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace Event_3_includesource</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            MyForm myfrom &#x3D; new MyForm();</span><br><span class="line">            myfrom.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyForm : Form</span><br><span class="line">    &#123;</span><br><span class="line">        private Button bt;</span><br><span class="line">        private TextBox tb;</span><br><span class="line">        public MyForm()</span><br><span class="line">        &#123;</span><br><span class="line">            bt &#x3D; new Button();</span><br><span class="line">            tb &#x3D; new TextBox();</span><br><span class="line">            this.Controls.Add(bt);</span><br><span class="line">            this.Controls.Add(tb);</span><br><span class="line">            bt.Click +&#x3D; this.Action;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Action(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            tb.Text &#x3D; DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件的拥有者包含着响应者</p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/event3.png" alt=""> </p>
</li>
<li><p>事件的拥有者同时也是响应者</p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/event4.png" alt=""> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace Event_2_same</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            MyForm myForm &#x3D; new MyForm();</span><br><span class="line">            myForm.Click +&#x3D; myForm.Action;</span><br><span class="line">            myForm.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyForm : Form</span><br><span class="line">    &#123;</span><br><span class="line">        internal void Action(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            this.Text &#x3D; DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>事件订阅的符号是+=，左边是事件本身，右边是事件处理器，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.button +&#x3D; this.ButtonClicked</span><br><span class="line">&#x2F;&#x2F;或着：</span><br><span class="line">this.button +&#x3D; this.EventHandle(this.ButtonClicked)</span><br><span class="line">&#x2F;&#x2F;或使用Lambda表达式</span><br><span class="line">this.button +&#x3D; (object sender,EventArgs e) &#x3D;&gt; &#123;</span><br><span class="line">	this.textBox.Text &#x3D; &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个事件可以挂接多个事件处理器，一个事件处理器也可以挂接多个事件</p>
<p><strong>自定义事件</strong></p>
<p>完整声明：（当不知道怎么做的时候，往上述的五个基本元素想就可以了）</p>
<ul>
<li>事件拥有者</li>
<li>事件本身</li>
<li>事件接收者</li>
<li>事件处理器</li>
<li>事件订阅</li>
</ul>
<p>众所周知，事件是声明在类中的，它是一个特殊的成员变量，所以要声明事件，首先要声明一个类。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Custmor </span><br><span class="line">&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件的本质，其实是委托的一个包装器，所以在声明一个事件之前，还要声明一个委托，用于约束事件处理器的各种参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate void OrderEventHandle(Custmor custmor,OrderEventArgs e);        &#x2F;&#x2F;声明了一个返回值为void，参数为Custmor和OrdereventArgs的委托</span><br><span class="line">&#x2F;&#x2F;Custmor是事件拥有者，OrderEventArgs是传递的消息</span><br></pre></td></tr></table></figure>

<p>OrderEventArgs不是系统类，需要自己定义，一般来说，消息类一般让它继承自系统的EventArgs类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OrderEventArgs : EventArgs</span><br><span class="line">&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了声明好的委托后，就可以在类中声明事件了，首先在类中声明委托</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Custmor        &#x2F;&#x2F;事件的拥有者</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	public OrderEventHandle orderEventHadle;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后声明事件，需要Event关键字和委托</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public event OrderEventHandle Order        </span><br><span class="line">&#123;</span><br><span class="line">	add</span><br><span class="line">	&#123;</span><br><span class="line">		this.orderEventHadle +&#x3D; value;</span><br><span class="line">	&#125;</span><br><span class="line">	remove</span><br><span class="line">	&#123;</span><br><span class="line">		this.orderEventHadle -&#x3D; value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像是多播一样，使用 + 来添加委托，因为相同类型的委托才可以被合并，所以一开始声明的委托就是为了约束。现在，事件拥有者，本身都有了，其他的处理器、接收者、订阅就和之前相同步骤就可以了</p>
<p><strong>使用委托的invoke函数即可触发事件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.orderEventHandle.Invoke();</span><br></pre></td></tr></table></figure>

<p>下面是一个餐馆服务员的服务订阅顾客点单事件的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace DiyEvent</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Custmor custmor &#x3D; new Custmor();</span><br><span class="line">            Waiter waiter &#x3D; new Waiter();</span><br><span class="line">            custmor.Order +&#x3D; waiter.Action;         &#x2F;&#x2F;事件订阅，waiter的Action订阅了custmor的Order事件</span><br><span class="line">            custmor.action();</span><br><span class="line">            custmor.PayMoney();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送的信息参数</span><br><span class="line">    public class OrderEventArgs : EventArgs</span><br><span class="line">    &#123;</span><br><span class="line">        public string DishName &#123; get; set; &#125;</span><br><span class="line">        public string Size &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public delegate void OrderEventHandle(Custmor custmor,OrderEventArgs e);    &#x2F;&#x2F;声明一个委托让事件包装</span><br><span class="line"></span><br><span class="line">    public class Custmor        &#x2F;&#x2F;事件的拥有者</span><br><span class="line">    &#123;</span><br><span class="line">        public int Cost &#123; get; set; &#125;</span><br><span class="line">        public void PayMoney()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I will pay &#123;0&#125;$&quot;,this.Cost);</span><br><span class="line">        &#125;</span><br><span class="line">        public OrderEventHandle orderEventHadle;    &#x2F;&#x2F;为了事件声明的委托</span><br><span class="line"></span><br><span class="line">        public event OrderEventHandle Order         &#x2F;&#x2F;事件本身</span><br><span class="line">        &#123;</span><br><span class="line">            add</span><br><span class="line">            &#123;</span><br><span class="line">                this.orderEventHadle +&#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove</span><br><span class="line">            &#123;</span><br><span class="line">                this.orderEventHadle -&#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void WalkInto()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Walk into the restround&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Sit()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Sit int the Chair&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void ThinkOrder()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;I am thinking&quot;);</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.orderEventHadle !&#x3D; null)    &#x2F;&#x2F;判断事件是否被订阅了</span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e &#x3D; new OrderEventArgs();</span><br><span class="line">                e.DishName &#x3D; &quot;Fish&quot;;</span><br><span class="line">                e.Size &#x3D; &quot;large&quot;;</span><br><span class="line">                this.orderEventHadle.Invoke(this, e);	&#x2F;&#x2F;通过委托触发事件</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.WalkInto();</span><br><span class="line">            this.Sit();</span><br><span class="line">            this.ThinkOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Waiter         &#x2F;&#x2F;事件接收者</span><br><span class="line">    &#123;</span><br><span class="line">        internal void Action(Custmor custmor, OrderEventArgs e)     &#x2F;&#x2F;事件处理器</span><br><span class="line">        &#123;</span><br><span class="line">            custmor.Cost &#x3D; 10;</span><br><span class="line">            switch (e.Size)</span><br><span class="line">            &#123;</span><br><span class="line">                case &quot;large&quot;:</span><br><span class="line">                    custmor.Cost &#x3D; 3 * custmor.Cost;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;small&quot;:</span><br><span class="line">                    custmor.Cost &#x3D; 2 * custmor.Cost;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;this is your &#123;0&#125;&quot;,e.DishName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简略声明：</strong></p>
<p>同样需要声明类和声明一个委托，然后原本需要在类中声明委托和事件，现在只需要一行代码即可完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public event OrderEventHandle Order;</span><br></pre></td></tr></table></figure>

<p>事件的触发需要改为事件名的 invoke()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.Order.invoke();</span><br></pre></td></tr></table></figure>

<p>下面是刚才的完整声明的简略声明版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace EasyDiyEvent</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Custmor custmor &#x3D; new Custmor();</span><br><span class="line">            Waiter waiter &#x3D; new Waiter();</span><br><span class="line">            custmor.Order +&#x3D; waiter.Action;        &#x2F;&#x2F;事件订阅，waiter的Action订阅了custmor的Order事件</span><br><span class="line">            custmor.action();</span><br><span class="line">            custmor.PayMoney();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送的信息参数</span><br><span class="line">    public class OrderEventArgs : EventArgs</span><br><span class="line">    &#123;</span><br><span class="line">        public string DishName &#123; get; set; &#125;</span><br><span class="line">        public string Size &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public delegate void OrderEventHandle(Custmor custmor, OrderEventArgs e);    &#x2F;&#x2F;声明一个委托让事件包装</span><br><span class="line"></span><br><span class="line">    public class Custmor        &#x2F;&#x2F;事件的拥有者</span><br><span class="line">    &#123;</span><br><span class="line">        public int Cost &#123; get; set; &#125;</span><br><span class="line">        public void PayMoney()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;I will pay &#123;0&#125;$&quot;, this.Cost);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public event OrderEventHandle Order;		&#x2F;&#x2F;不需要声明委托，直接声明事件</span><br><span class="line"></span><br><span class="line">        public void WalkInto()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Walk into the restround&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Sit()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Sit int the Chair&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void ThinkOrder()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;I am thinking&quot;);</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.Order !&#x3D; null)			&#x2F;&#x2F;判断事件是否被订阅</span><br><span class="line">            &#123;</span><br><span class="line">                OrderEventArgs e &#x3D; new OrderEventArgs();</span><br><span class="line">                e.DishName &#x3D; &quot;Fish&quot;;</span><br><span class="line">                e.Size &#x3D; &quot;large&quot;;</span><br><span class="line">                this.Order.Invoke(this, e);			&#x2F;&#x2F;改为通过Order事件成员来触发事件</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void action()</span><br><span class="line">        &#123;</span><br><span class="line">            this.WalkInto();</span><br><span class="line">            this.Sit();</span><br><span class="line">            this.ThinkOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Waiter         &#x2F;&#x2F;事件接收者</span><br><span class="line">    &#123;</span><br><span class="line">        internal void Action(Custmor custmor, OrderEventArgs e)     &#x2F;&#x2F;事件处理器</span><br><span class="line">        &#123;</span><br><span class="line">            custmor.Cost &#x3D; 10;</span><br><span class="line">            switch (e.Size)</span><br><span class="line">            &#123;</span><br><span class="line">                case &quot;large&quot;:</span><br><span class="line">                    custmor.Cost &#x3D; 3 * custmor.Cost;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;small&quot;:</span><br><span class="line">                    custmor.Cost &#x3D; 2 * custmor.Cost;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;this is your &#123;0&#125;&quot;, e.DishName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的介绍，我们可以知道</p>
<p>​    事件本质上是一个委托字段的包装器，这个包装器对委托字段的访问起了限制作用，对外界隐藏了委托实例的大部分功能，仅暴露添加/移除事件处理器的功能</p>
<p><strong>为什么需要有事件？</strong></p>
<p>最重要的一点就是，事件在拥有者外部，只能执行 += 或者 -= 操作（即仅暴露添加、移除事件处理器的功能），但是如果是事件的话，可以外部使用Invoke等功能，这样没有限制的话肯能会导致程序编写时出错，总而言之就是为了使得程序的逻辑更“有道理”，更加安全</p>
<p><strong>用于声明事件的委托类型的约定俗成的命名约定</strong></p>
<ul>
<li><p>事件名 + EventHandler</p>
<p>​    如Foo事件的委托，一般命名为FooEventHandler</p>
</li>
<li><p>参数一般有两个</p>
<ul>
<li>第一个是object类型，名为sender，也就是事件的拥有者，事件的source</li>
<li>第二个是EventArgs的拍成类，一般命名为： 事件名 +     EventArgs，参数名为e</li>
<li>触发事件的方法一般命名为：On事件名，访问级别应设置为protect，不能为Public，防止外界访问</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>委托</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>C#面向对象</title>
    <url>/2020/10/11/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="C-结构体与类"><a href="#C-结构体与类" class="headerlink" title="C#结构体与类"></a>C#结构体与类</h1><p>类和结构有以下几个基本的不同点：</p>
<ul>
<li>类是引用类型，结构是值类型</li>
<li>结构不支持继承</li>
<li>结构不能声明默认的（即无参）构造函数</li>
<li>结构体中声明的字段无法赋予初值，类可以</li>
<li>结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用</li>
</ul>
<a id="more"></a>

<h2 id="C-类"><a href="#C-类" class="headerlink" title="C#类"></a>C#类</h2><hr>
<p>类的三大成员<br>{<br>    <strong>属性</strong>    (成员变量)<br>    <strong>方法</strong>    (成员函数)<br>    <strong>事件</strong>    (类或对象通知其他类或对象的机制，为C#独有，如窗体程序的Click事件)<br>}  </p>
<hr>
<p>成员的静态、动态<br>{<br>    静态成员是类的成员<br>    实例(非静态)成员是对象的成员<br>}  </p>
<p>程序的静态、动态<br>{<br>    程序未执行是，称为程序的静态(编辑期和编译期)，执行起来时，称为程序的动态或执行时期(运行器)<br>    静态程序在硬盘（外存）中，动态程序在内存中<br>}  </p>
<hr>
<h2 id="C-类的静态成员"><a href="#C-类的静态成员" class="headerlink" title="C# 类的静态成员"></a>C# 类的静态成员</h2><ul>
<li>可以使用 static 关键字把类成员定义为静态的。当声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本</li>
<li>把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在</li>
</ul>
<h2 id="C-属性"><a href="#C-属性" class="headerlink" title="C#属性"></a>C#属性</h2><p>属性：（类似字段）</p>
<ul>
<li><p>属性是一种用于访问对象或类型特征的成员，特征反映了状态</p>
</li>
<li><p>一个类可以设置多个属性</p>
</li>
<li><p>属性大多数情况下是字段的包装器，建议只使用属性来暴露数据，字段设置为private和protected</p>
</li>
<li><p>字段可能会被非法数据污染，而属性可以通过逻辑写法避免</p>
</li>
</ul>
<p>语法：</p>
<p>​        特性(可选)  修饰符  类型  成员名称  { get与set }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int public age;</span><br><span class="line">Public int Age</span><br><span class="line">&#123;</span><br><span class="line">	get&#123;</span><br><span class="line">		return age;</span><br><span class="line">		&#125;</span><br><span class="line">	set&#123;</span><br><span class="line">		age &#x3D; value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在VS中可以快速的写好完整的属性声明，可以敲击propfull，然后连续敲击两次Tap键，即可自动生成完整的属性声明代码</p>
<h2 id="C-索引器"><a href="#C-索引器" class="headerlink" title="C#索引器"></a>C#索引器</h2><p>索引器得对象能够使用与数组下同的方式（即下标）进行索引，</p>
<p>索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型，索引器（Indexer）可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element-type this[int index]</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; get 访问器</span><br><span class="line">   get&#123;</span><br><span class="line">      &#x2F;&#x2F; 返回 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F; set 访问器</span><br><span class="line">   set&#123;</span><br><span class="line">      &#x2F;&#x2F; 设置 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引器的行为的声明在某种程度上类似于属性（property）。定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 <strong>this</strong> 关键字，它指向对象实例</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class IndexedNames</span><br><span class="line">&#123;</span><br><span class="line">    private string[] namelist &#x3D; new string[size];</span><br><span class="line">    static public int size &#x3D; 10;</span><br><span class="line">    public IndexedNames()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            namelist[i] &#x3D; &quot;N. A.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public string this[int index]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp;</span><br><span class="line"></span><br><span class="line">            if (index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size - 1)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp &#x3D; namelist[index];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                tmp &#x3D; &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return (tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            if (index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size - 1)</span><br><span class="line">            &#123;</span><br><span class="line">                namelist[index] &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C#继承"></a>C#继承</h2><p>一个类可以派生自类、多个接口<br>C#不支持多继承，但是可以使用接口来实现多继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;访问修饰符符&gt; class &lt;基类&gt;</span><br><span class="line">&#123;</span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;访问修饰符符&gt; interface &lt;接口&gt;</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">class &lt;派生类&gt; : &lt;基类&gt; , &lt;接口&gt;</span><br><span class="line">&#123;</span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class shape</span><br><span class="line">&#123;</span><br><span class="line">	….</span><br><span class="line">&#125;</span><br><span class="line">public interface cost</span><br><span class="line">&#123;</span><br><span class="line">	….</span><br><span class="line">&#125;</span><br><span class="line">Class Rectangle : shape , cost</span><br><span class="line">&#123;</span><br><span class="line">	….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C#多态"></a>C#多态</h2><h3 id="静态多态性质"><a href="#静态多态性质" class="headerlink" title="静态多态性质"></a>静态多态性质</h3><ul>
<li>函数重载<br>函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。但是不能重载只有返回类型不同的函数声明</li>
<li>运算符重载<ul>
<li>重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表</li>
<li>C#要求所有的运算符重载都声明为public和static，这表示它们与它们的类或结构相关联，而不是与实例相关联</li>
<li>可重载和不可重载运算符表</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+, -, !, ~, ++, –</td>
<td align="center">这些一元运算符只有一个操作数，且可以被重载</td>
</tr>
<tr>
<td align="center">+, -, *, /, %</td>
<td align="center">这些二元运算符带有两个操作数，且可以被重载</td>
</tr>
<tr>
<td align="center">==, !=, &lt;, &gt;, &lt;=, &gt;=</td>
<td align="center">这些比较运算符可以被重载</td>
</tr>
<tr>
<td align="center">&amp;&amp;, | |</td>
<td align="center">这些条件逻辑运算符不能被直接重载</td>
</tr>
<tr>
<td align="center">+=, -=, *=, /=, %=</td>
<td align="center">这些赋值运算符不能被重载</td>
</tr>
<tr>
<td align="center">=, ., ?:, -&gt;, new, is, sizeof, typeof</td>
<td align="center">这些运算符不能被重载</td>
</tr>
</tbody></table>
<h3 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h3><ul>
<li>使用抽象类<br>  使用关键字 abstract 创建抽象类、抽象方法，用于提供接口的部分类的实现  <ul>
<li>不能创建一个抽象类的实例</li>
<li>不能在一个抽象类外部声明一个抽象方法</li>
<li>一个抽象类可以同时包含抽象方法和非抽象方法</li>
<li>抽象方法只在派生类中真正实现，这表明抽象方法只存放函数原型，不涉及主体代码</li>
<li>在类定义前面放置关键字sealed可以将类声明为密封类，密封类不能被继承，故抽象类不能被声明为sealed</li>
</ul>
</li>
</ul>
<p><strong>子类继承抽象类时需要使用override来重写方法，override只能重写抽象方法和虚方法，抽象类也不能被多继承</strong></p>
<ul>
<li>使用虚方法<br>  当有一个定义在类中需要在继承类中实现时，可使用虚方法<ul>
<li>关键字：vitual</li>
<li>虚方法可以在不同类中有不同的个实现</li>
<li>动态多态性是通过抽象类和虚方法实现的</li>
</ul>
</li>
</ul>
<h1 id="C-接口"><a href="#C-接口" class="headerlink" title="C#接口"></a>C#接口</h1><p>声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;访问修饰符符&gt; interface &lt;接口名&gt;</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用interface声明接口，与类的声明类似，接口声明默认是public，在namespace中类默认为internal权限</li>
<li>如果两个接口中有完全相同的签名，那么可以用“接口名.方法名”的方法显式的来实现接口</li>
<li>抽象类可以实现接口，而且可以<strong>只实现部分</strong>接口。</li>
<li>接口做为参数传递，传递的是实现了接口的对象；</li>
<li>接口作为类型返回，返回的是实现了接口的对象。</li>
</ul>
<h1 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C#命名空间"></a>C#命名空间</h1><ul>
<li>using static<br>  using static指令可以直接访问静态成员类型，如:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using static System.Math;</span><br><span class="line">Var I &#x3D; PI;</span><br><span class="line">                </span><br><span class="line">using static System.console;</span><br><span class="line">Writeline(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">* 命名空间别名</span><br><span class="line">    可以使用别名替代原命名空间名</span><br><span class="line">    &#96;&#96;&#96;c#</span><br><span class="line">    using 别名 &#x3D; 指定命名空间名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-枚举"><a href="#C-枚举" class="headerlink" title="C#枚举"></a>C#枚举</h1><p>声明枚举的一般语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum &lt;enum_name&gt;</span><br><span class="line">&#123; </span><br><span class="line">    enumeration list   &#x2F;&#x2F;enumeration list 是一个用逗号分隔的标识符列表</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="C-不安全代码块"><a href="#C-不安全代码块" class="headerlink" title="C#不安全代码块"></a>C#不安全代码块</h1><p>在C#中，如果想使用指针，需要在方法前添加unsafe关键字，或者使用<br>unsafe{<br>    xxxxx<br>}<br>如果想使用unsafe代码块，需要在PROJECT栏的Stackoverflow 中的Build里勾选Allow unsafe code  </p>
<h1 id="C-预处理指令"><a href="#C-预处理指令" class="headerlink" title="C#预处理指令"></a>C#预处理指令</h1><p>C#预处理指令，用于在条件编译中起作用，与C和C++不同的是，C#的预处理指令不是用来创建宏的</p>
<p>C#预处理指令列表：<br>|预处理指令|描述|<br>|:–|:–|<br>|#define|C#预处理指令|<br>|#undef|它用于取消定义符号|<br>|#if|它用于测试符号是否为真|<br>|#else|它用于创建复合条件指令，与 #if 一起使用|<br>|#elif|它用于创建复合条件指令|<br>|#endif|指定一个条件指令的结束|<br>|#line|它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名|<br>|#error|它允许从代码的指定位置生成一个错误|<br>|#warning|它允许从代码的指定位置生成一级警告|<br>|#region|它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块|<br>|#endregion|它标识着 #region 块的结束|</p>
<ul>
<li><p>#define 预处理器<br>可以定义一个符号，然后如果传递给#if指令的表达式，表达式会返回true，说明该符号已定义<br>例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PI</span><br><span class="line">using System;</span><br><span class="line">namespace PreprocessorDAppl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            #if (PI)</span><br><span class="line">            Console.WriteLine(&quot;PI is defined&quot;);</span><br><span class="line">            #else</span><br><span class="line">            Console.WriteLine(&quot;PI is not defined&quot;);</span><br><span class="line">            #endif</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件指令<br>可以用 #If来创建一个条件指令，条件指令用于测试符号是否为真。类似与if的使用方法,<strong>一个以 #if 指令开始的条件指令，必须显示地以一个 #endif 指令终止！</strong></p>
</li>
<li><p>#warning和#error：<br>当编译器遇到#warning指令时，会给用户显示#warning指令后面的文本<br>当编译器遇到#error指令时，会给用户显示#error指令后面的文本，并立即退出编译<br>示例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if DEBUG &amp;&amp; RELEASE  </span><br><span class="line">#error &quot;You&#39;ve defined DEBUG and RELEASE simultaneously!&quot;  </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#warning &quot;Don&#39;t forget to remove this line before the boss tests the code!&quot;  </span><br><span class="line">Console.WriteLine(&quot;*I hate this job.*&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>#region和#endredgion<br>这两个指令用于把一段代码标记为有给定名称的一个块，它不影响编译过程，优点是可以被某些编辑器识别，可以使代码在屏幕上更好的布局</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#region Member Field Declarations</span><br><span class="line">int x;</span><br><span class="line">double d;</span><br><span class="line">Currency balance;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C#异常处理"></a>C#异常处理</h1><p>C#的异常处理建立在：try、catch、finally和throw上</p>
<ul>
<li>try：一个try块标识了一个将被激活的特定的异常的代码块，后跟一个或者多个catch块</li>
<li>catch：程序通过异常处理程序捕获异常。catch关键字表示异常的捕获</li>
<li>finally：finally块用于执行给定的语句，不管异常是否被抛出都会执行</li>
<li>throw：当问题出现时，程序抛出异常，使用throw关键字来完成</li>
</ul>
<p>使用try/catch的语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">	&#123;</span><br><span class="line">	   &#x2F;&#x2F; 引起异常的语句</span><br><span class="line">	&#125;</span><br><span class="line">	catch( ExceptionName e1 )</span><br><span class="line">	&#123;</span><br><span class="line">	   &#x2F;&#x2F; 错误处理代码</span><br><span class="line">	&#125;</span><br><span class="line">	catch( ExceptionName e2 )</span><br><span class="line">	&#123;</span><br><span class="line">	   &#x2F;&#x2F; 错误处理代码</span><br><span class="line">	&#125;</span><br><span class="line">	catch( ExceptionName en )</span><br><span class="line">	&#123;</span><br><span class="line">	   &#x2F;&#x2F; 错误处理代码</span><br><span class="line">	&#125;</span><br><span class="line">	finally</span><br><span class="line">	&#123;</span><br><span class="line">	   &#x2F;&#x2F; 要执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-中的异常类"><a href="#C-中的异常类" class="headerlink" title="C#中的异常类"></a>C#中的异常类</h1><ul>
<li>C# 中的异常类主要是直接或间接地派生于 System.Exception 类</li>
<li>System.ApplicationException 和 System.SystemException 类是派生于 System.Exception 类的异常类<ul>
<li>System.ApplicationException 类支持由应用程序生成的异常。所有程序员定义的异常都应派生自该类</li>
<li>System.SystemException 类是所有预定义的系统异常的基类</li>
</ul>
</li>
</ul>
<p>自定义异常类<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户可以自定义异常类，异常类继承自ApplicationException类<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace UserDefinedException</span><br><span class="line">&#123;</span><br><span class="line">   class TestTemperature</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         Temperature temp &#x3D; new Temperature();</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            temp.showTemp();</span><br><span class="line">         &#125;</span><br><span class="line">         catch(TempIsZeroException e)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(&quot;TempIsZeroException: &#123;0&#125;&quot;, e.Message);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TempIsZeroException: ApplicationException</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F;继承自ApplicationException类，创建参数为字符串类型的构造函数</span><br><span class="line">   public TempIsZeroException(string message): base(message)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Temperature</span><br><span class="line">&#123;</span><br><span class="line">   int temperature &#x3D; 0;</span><br><span class="line">   public void showTemp()      &#x2F;&#x2F;显示函数，在temperature &#x3D; 0时抛出异常，否则正常打印</span><br><span class="line">   &#123;</span><br><span class="line">      if(temperature &#x3D;&#x3D; 0)</span><br><span class="line">      &#123;</span><br><span class="line">         throw (new TempIsZeroException(&quot;Zero Temperature found&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Temperature: &#123;0&#125;&quot;, temperature);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>面向对象</tag>
        <tag>异常处理</tag>
        <tag>预处理指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>next主题的安装使用 ···持续更新</title>
    <url>/2020/06/06/next%E4%B8%BB%E9%A2%98%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装并启用next主题"><a href="#安装并启用next主题" class="headerlink" title="安装并启用next主题"></a>安装并启用next主题</h1><h2 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h2><p>&ensp;&ensp;首先在终端进入blog目录<br>&ensp;&ensp;输入命令：（务必确定是在博客根目录下，可使用 <strong>pwd</strong> 查看路径）</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件启用next主题"><a href="#修改配置文件启用next主题" class="headerlink" title="修改配置文件启用next主题"></a>修改配置文件启用next主题</h2><p>&ensp;&ensp;在博客的根目录下找到 <strong>_config.yml</strong> ，使用编辑器打开(推荐使用vs code)<br><img src="https://raw.githubusercontent.com/pink-star/image/master/config.png" alt=""><br>&ensp;&ensp;在大概80-100行之间找到<br>&ensp;&ensp; <strong>theme: landscape</strong><br>&ensp;&ensp;将其改为 <strong>theme: next</strong>即可启用主题</p>
<h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><ul>
<li><p>清楚缓存&ensp;&ensp;（这样做是为了清除缓存文件 (db.json) 和已生成的静态文件 (public)。当有时发现hexo s怎么也看不到变化时候，可能需要clean再generate一下） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li>
<li><p>重新构建 &ensp;&ensp;（用于生成静态文件 ） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务  (本地预览查看效果)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后可以到浏览器打开localhost:4000查看效果。如下图：<br><img src="https://raw.githubusercontent.com/pink-star/image/master/next.png" alt=""><br>next主题的安装就结束了</p>
<h1 id="next主题美化"><a href="#next主题美化" class="headerlink" title="next主题美化"></a>next主题美化</h1><h2 id="基本信息更改"><a href="#基本信息更改" class="headerlink" title="基本信息更改"></a>基本信息更改</h2><p>&ensp;&ensp;在根目录下的 <strong>_config.yml</strong> 找到<strong>Site</strong>字段，按照自己需要进行更改即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/site.jpg" alt=""><br>title: 标题<br>subtitle: 副标题<br>description: 描述<br>keywords: 关键词<br>author: 作者<br>language: 语言（中文是zh-CN）<br>timezone: 网站时区(不填即可)<br>更改玩后clean一下重新构建即可看到效果</p>
<h2 id="更改主题样式"><a href="#更改主题样式" class="headerlink" title="更改主题样式"></a>更改主题样式</h2><p>next提供了四种主题样式，我们可以在next文件夹下的 <strong>config.yml</strong>进修修改即可<br>在 <strong>config.yml</strong> 中找到 Scheme Settings字段，想要启用哪一种样式，只需要将其他注释掉，将想要展示的样式前的#去掉即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/shame.jpg" alt=""></p>
<h2 id="菜单配置"><a href="#菜单配置" class="headerlink" title="菜单配置"></a>菜单配置</h2><p>刚开始的默认菜单只开启了”首页”和”归档两个”，为了开启其他的菜单项<br>打开根目录下的 <strong>_config.yml</strong> 找到 <strong>Menu Settings</strong> 将需要开启的菜单项前面的#去掉即可  </p>
<p><img src="https://raw.githubusercontent.com/pink-star/image/master/1591449707(1).png" alt=""></p>
<p>但此时点击其他菜单项是没有东西显示的，这是我们需要新建一些页面,终端中输入</p>
<ul>
<li>创建标签页<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li>创建分类页<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
这时source文件夹下有了categorcies和tags两个文件夹，打开里面的index.md文件进行编辑<br>添加  type: tags字段，categories就文件夹下的就改为categories即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/targ.jpg" alt=""><br>这时点击响应菜单栏就可以打开了</li>
</ul>
<p>以后写文章只需要添加<br>tags:<br>  - 标签1<br>  - 标签2<br>  …<br>categories: xxx<br>即会自动添加标签和进行分类  </p>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>打开next目录下的 <strong>config.yml</strong> 文件，找到<strong>Sidebar Avatar</strong>字段，按照需要更改即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/head.jpg" alt=""><br>url: 头像的路径<br>rounded: true （true时，头像为圆形，false时为方形）<br>rotate: true （true时，鼠标移动到头像上方头像会旋转，离开时回到原位）  </p>
<h2 id="设置侧边社交栏"><a href="#设置侧边社交栏" class="headerlink" title="设置侧边社交栏"></a>设置侧边社交栏</h2><p>打开next文件夹下的 <strong>config.yml</strong><br>找到Social Links字段，将想要链接的那一栏的#去掉即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/link.jpg" alt=""><br>还可以增加自定义链接，如增加一个BiliBili个人空间的链接：<br>BiliBili: 你的空间地址 || fab fa-对应图标<br>图标可以到<a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">Font Awesome</a>中找到  </p>
<h2 id="设置友联"><a href="#设置友联" class="headerlink" title="设置友联"></a>设置友联</h2><p>打开next文件夹下的 <strong>config.yml</strong><br>找到Blog rolls字段<br><img src="https://raw.githubusercontent.com/pink-star/image/master/friend.jpg" alt=""><br>需要更改自己需要的字段即可<br>  icon: fa fa-link  （友链图标）<br>  title: Links  （你的友链的名称，如我的友链叫友人帐）<br>  layout: block  (样式，提供了两个，喜欢哪个用哪个)<br>  Title: <a href="http://yoursite.com">http://yoursite.com</a>  (Title为要增加的的友链的名称，后面为对应的链接地址)  </p>
<h2 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h2><p>打开next文件夹下的 <strong>config.yml</strong><br>找到Reward 字段<br><img src="https://raw.githubusercontent.com/pink-star/image/master/reward.jpg" alt=""><br>enable: 字段为true则默认开启打赏功能<br>animation: 字段则是当鼠标移动到付款码上方文字会有一个抖动效果<br>接着按照自己的需要开启自己需要的支付方式即可  </p>
<h2 id="添加Fork-Github"><a href="#添加Fork-Github" class="headerlink" title="添加Fork Github"></a>添加Fork Github</h2><p>首先我们打开<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corner</a>，选择一个自己喜欢的样式，然后复制相应代码<br>接下来打开next文件下下的layout文件下的_layout.swig文件，找到  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>将刚刚复制的代码粘贴到他后面，然后将刚刚复制的代码的中的<br><strong><a href="https://your-url" target="_blank" rel="noopener">https://your-url</a></strong>改为自己的GitHub地址即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/frok.jpg" alt=""><br>然后重新clean一下再构建，即可看见效果  </p>
<h2 id="修改文章底部标签样式"><a href="#修改文章底部标签样式" class="headerlink" title="修改文章底部标签样式"></a>修改文章底部标签样式</h2><p>打开next/layout/_macro下的 <strong>post.swig</strong> 文件，找到footer字段<br><img src="https://raw.githubusercontent.com/pink-star/image/master/footer.jpg" alt=""><br>然后将 改为 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;i class &#x3D; &quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>
<p>“fa fa-tag”根据需要自行更换</p>
<h2 id="启用Valine评论功能"><a href="#启用Valine评论功能" class="headerlink" title="启用Valine评论功能"></a>启用Valine评论功能</h2><p>首先打开 <a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud官网</a>,注册一个账号，然后创建一个应用<br>找到该界面，辅助AppID,AppKey<br><img src="https://raw.githubusercontent.com/pink-star/image/master/vline.png" alt=""><br>打开next文件夹下的 <strong>_config.yml</strong> 找到 <strong>Valine</strong>字段<br><img src="https://raw.githubusercontent.com/pink-star/image/master/appkey.jpg" alt=""><br>将enable字段改为true，并且将刚刚复制AppKey，和AppID粘贴到对应栏即可</p>
<h2 id="启用搜索功能"><a href="#启用搜索功能" class="headerlink" title="启用搜索功能"></a>启用搜索功能</h2><p>next主题集成了Swiftype、 微搜索、Local Search 和 Algolia，大家有需要可以自行搜索其他的，这里只演示local search如何开启</p>
<ul>
<li><p>在博客根目录下打开终端，运行下命令来安装 <strong>hexo-generator-searchdb</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开博客根目录下的 <strong>_config.yml</strong> 文件，<strong>添加</strong>下列字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
<li><p>打开next目录下的 <strong>_config.yml</strong> 文件，找到 <strong>local_search</strong> 字段，将enable字段值改为true就大功告成了<img src="https://raw.githubusercontent.com/pink-star/image/master/localsearch.jpg" alt=""></p>
</li>
</ul>
<h2 id="增加内容分享功能"><a href="#增加内容分享功能" class="headerlink" title="增加内容分享功能"></a>增加内容分享功能</h2><ul>
<li>首先在<a href="https://www.addthis.com/" target="_blank" rel="noopener">Addthis官网</a>注册登录，然后网站会叫你选择功能，选择share button即可。   </li>
<li>然后打开个人资料设置，将里面的编号复制下来<img src="https://raw.githubusercontent.com/pink-star/image/master/bh.jpg" alt=""></li>
<li>打开next文件夹下的 <strong>_config.yml</strong> 文件，找到add_this_id字段，将刚刚复制的编号粘贴进去即可<img src="https://raw.githubusercontent.com/pink-star/image/master/addthisid.jpg" alt=""></li>
</ul>
<h2 id="将底部的由-Hexo-amp-NexT-Pisces-强力驱动隐藏"><a href="#将底部的由-Hexo-amp-NexT-Pisces-强力驱动隐藏" class="headerlink" title="将底部的由 Hexo &amp; NexT.Pisces 强力驱动隐藏"></a>将底部的<strong>由 Hexo &amp; NexT.Pisces 强力驱动</strong>隐藏</h2><p>打开<strong>Blog/themes/next/layout/_partials</strong>文件夹下的<strong>footer.swig</strong>文件<br>找到<strong>theme.footer.powered</strong>字段，将这一大段代码注释掉或者删除即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/footswig.jpg" alt=""></p>
<h2 id="背景图片、透明度等自定义美化效果"><a href="#背景图片、透明度等自定义美化效果" class="headerlink" title="背景图片、透明度等自定义美化效果"></a>背景图片、透明度等自定义美化效果</h2><ul>
<li>打开博客根目录下的source文件夹，在里面新建一个_data文件夹，并创建一个<strong>styles.styl</strong>文件</li>
<li>打开next文件夹下的 <strong>_config.yml</strong> 文件，找到custom_file_path字段，将最后一行的style注释去掉即可<img src="https://raw.githubusercontent.com/pink-star/image/master/custom.jpg" alt=""></li>
<li>这时我们就可以在<strong>styles.styl</strong>文件夹下自行添加css语句来自定义样式了，比如添加背景图片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(你的图片路径);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vs中类库引用</title>
    <url>/2020/10/11/Vs%E4%B8%AD%E7%B1%BB%E5%BA%93%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="类库的引用"><a href="#类库的引用" class="headerlink" title="类库的引用"></a>类库的引用</h1><p>类库的引用时使用命名空间和类的物理基础，类库的引用分两种，一种是dll（即动态链接库引用），一种是项目引用</p>
<ul>
<li>dll-动态链接引用（黑盒引用，无源代码）<ul>
<li>dll引用缺点：引用一个库可能还需要引用下层类库，非则会报错，麻烦且不安全</li>
<li>NuGet使用：可以直接引用打包好的类库，无需检查是否有遗漏（NuGet是vs的一个扩展工具，可以让我们在项目中添加、删除、更新引用变得更加快捷方便）</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>项目引用（白盒引用，有源代码）</li>
</ul>
<h2 id="添加一个项目引用："><a href="#添加一个项目引用：" class="headerlink" title="添加一个项目引用："></a>添加一个项目引用：</h2><ul>
<li>首先要将项目包含到自己的解决方案里面，(一个项目能够被多个solution包含，叫project的重用)  </li>
</ul>
<ol>
<li>在解决方案中添加需要引用的project，右击解决方案然后添加一个Existing Project，找到对应的proj文件即可文件<br><img src="https://raw.githubusercontent.com/pink-star/image/master/1.jpg" alt="01"></li>
<li>选择添加Reference然后在Projects栏中的Solution中即可看到刚刚添加的项目，选中添加即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/2.jpg" alt="02"></li>
</ol>
<h2 id="添加一个动态链接库引用"><a href="#添加一个动态链接库引用" class="headerlink" title="添加一个动态链接库引用"></a>添加一个动态链接库引用</h2><p>只需在添加Reference界面选择对应的dll文件即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/3.jpg" alt="03"></p>
<h2 id="自建类库项目"><a href="#自建类库项目" class="headerlink" title="自建类库项目"></a>自建类库项目</h2><p>创建一个Class Library项目（非可执行程序，编译出来的结果就是dll文件），然后即可将该dll文件引用到需要的地方即可<br><img src="https://raw.githubusercontent.com/pink-star/image/master/4.jpg" alt="04"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>库引用</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻引擎笔记</title>
    <url>/2020/06/05/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="暂时先这样写"><a href="#暂时先这样写" class="headerlink" title="暂时先这样写"></a>暂时先这样写</h1><ul>
<li>正文日后补上</li>
</ul>
<a id="more"></a>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>游戏开发</tag>
        <tag>C++</tag>
        <tag>蓝图</tag>
      </tags>
  </entry>
</search>
